笔记
树
有关树的概念
树的定义：树是n(n>0)个结点的有限集,这个集合满足：
有且只有一个结点没有前驱（没有父亲节点），这个结点为树的根；
除根外，其余的每个结点都有且仅有一个前驱；
除根外，每一个结点都通过唯一的路径连到根上（否则有环），且路径上每一个结点都是前一个结点的儿子。
树没有封闭的回路，否则就是图了
几种形态的树
结点的分类
（1）. 根结点：没有父亲的结点。在树中有且仅有一个根结点。
（2）. 分支结点：除根结点外，有孩子的结点称为分支结点(根节点也算一个分支结点)。
（3）. 叶结点：没有孩子的结点称为树叶。根结点到每一个分支结点或叶结点的路径是唯一的。
有关度
(1) 结点的度：一个结点的子树数目称为该结点的度；
(2) 树的度：所有结点中最大的度成为该树的度（宽度）。
树的深度（高度）
树是分层次的。结点所在的层次是从根算起的。根结点在第一层，根的儿子在第二层，其余各层依次类推。
树的最大层次称为树的深度或高度。
树的存储
父亲表示法（重点掌握）
定义一个数组，每个数组元素为一个记录，除了存放一个结点的数据信息外，还存放该结点的父结点编号。可以通过一个结构体来实现。
#define m 10; //树的结点数
struct node{
    int data; //数据域，如果没有，可以不记录
    int parent; //父结点
}
//int tree[maxn][2];//另一种存储方法，利用二维数组
优点：利用树中除根结点外每个节点都有唯一的父结点这个性质，很容易找到树根；
缺点：找孩子时需要遍历整个线性表
树的遍历
 按照某种次序获得树中全部结点的信息，即为树的遍历。
前序（根）遍历：先访问根节点，再从左到右按照前序思想遍历；（12564789）
后序（根）遍历：从左到右遍历各棵子树，再访问根结点；（56289741）
//先序遍历——深搜
//１.读入数据 
      cin>>n;
      for(i=1;i<=n;i++) cin>>tree[i][1]>>tree[i][2];
//２.寻找根节点 
      root=1; 
      while(tree[root][2]!=0)root=tree[root][2]; //寻找根节点 
 //3.先序遍历树
      void dfs(int k){    //深度优先遍历
          cout<<tree[k][1]<<“  ”;   //输出当前节点
          for(i=1;i<=n;i++)
               if(tree[i][2]==k) dfs(i);  //遍历当前节点孩子
      }
二叉树
基本概念
是一种特殊的树，但是每个结点最多有两个孩子，且其子树有左右之分；
即每个结点只能有0、1或2个孩子；
与树的区别：
树的每个结点可以有多个孩子，二叉树不能超过2个
树的子树可以不分次序，二叉树要分左儿子和右儿子。
五种基本形态
二叉树的两种特殊形态：
满二叉树：深度为k的二叉树，共有2k-1个结点，即第i层有2i-1 个结点，下图左；
满二叉树：一棵二叉树，最多只有最下面两层结点度数可以小于2，并且最下面一层的结点都集中在该层最左边的若干位置上，如下图右；
二叉树的三个主要性质
性质1：在二叉树的第i（i≥1）层上，最多有2i-1个结点
性质2：在深度为k(k≥1)的二叉树中最多有2k-1个结点。
性质3：在任何二叉树中，叶子结点数总比度为2的结点多1。
即 n0=n2+1
(设n0为二叉树的叶结点数；n2为二叉树中度为2的结点数)
二叉树的存储
顺序存储-记录儿子
将每个结点的信息存放在一维数组中，记录该结点的数据值（如果有）、父结点编号、左儿子编号、右儿子编号。
#define M 10 //树中结点数的上限
struct treetype{
    int data;
    int prt,lch,rch;//父结点，左儿子、右儿子编号
}tree[M]；
二叉树的遍历
前序：（1）访问根节点；（2）前序遍历左子树；（3）前序遍历右子树；
中序：（1）中序遍历左子树；（2）访问处理根节点；（3）中序遍历右子树；
后序：（1）后序遍历左子树；（2）后序遍历右子树；（3）访问处理根节点；

图论
图的基本概念
1.无向图：无向图中用不带箭头的边连接两个有关联的结点；在具有n个结点的无向图中，边的最大数目为n*(n-1)/2。而边数达到最大值的图称为无向完全图。
有向图：通常用带箭头的边连接两个有关联的结点(方向由前件指向后件)。有向图中一个结点的后件个数称为该结点的出度,其前件个数称为该结点的入度。
简单路径：如果一条路径上的结点除起点x1和终点xk可以相同外，其它结点均不相同，则称此路径为一条简单路径。
回路：x1=xk的简单路径称为回路（也称为环）。
连通图： 对于无向图而言，若其中任两个结点之间连通，则称该图为连通图。一个无向图的连通分支定义为此图的最大连通子图。如下图：
图的存储
邻接矩阵存储-二维数组(时空复杂度都是N2)
无向图的邻接矩阵(以对角线为界左右对称)
有向图的邻接矩阵（非对称）
当图中的边数远比n2少得多时，构成稀疏矩阵，空间浪费较大。
邻接表存储(时空复杂度为M边数)
图的遍历
图的遍历算法，是求解图的连通性问题、拓扑排序、最短路和关键路径等算法的基础，通常有两种
深度优先遍历
类似于树的前序遍历；
假设初始时所有结点未曾被访问。深度优点搜索从某个结点V0出发，访问此结点。然后依次从V0的未被访问的邻接点出发深度优先遍历图，直到所有和V0有路径相连的点都被访问到。
若此时图中尚有结点未被访问，则另选一个未曾访问的结点作起始点，重复上述过程，直至图中所有结点都被访问为止。
如果从v3出发： 则遍历结果是：V3->V2->V1->V5->V4
//邻接矩阵初始化；
void dfs(int i) {   //深搜
   f[i]=true;  //置结点i为已访问标记
   for(j=1;j<=n;j++)    //按深度优先搜索的顺序遍历vi所有子树
         if ( ! f[ j ] && a[i][j] == 1)   dfs(j);   
	}
    // 调用一次dfs(i),可按深度优先搜索的顺序访问处理结点i所在的连通分支(或强连通分支)。
//整个图按深度优先搜索顺序遍历的过程如下：
void travel()
{
   	memset(f,0,sizeof(f));   //置所有结点未访问标志
   	for(i=1;i<=n;i++)
        if(!f[i]) dfs(i);  //深度优先搜索每一个未访问的结点
}
广度优先遍历
在访问了v0之后依次访问v0的各个未曾访问的邻接点；
然后分别从这些邻接点出发按广度优先搜索的顺序遍历图，直至图中所有可被访问的结点都被访问到。
若此时图中尚有结点未被访问，则任选其中的一个作起始点，重复上述过程，直至图中所有结点都被访问到为止。
换句话说，按广度优先顺序搜索遍历图的过程是以v0为起始点，由近及远，依次访问和v0有路径相连且路径长度为1，2，3……的结点。
从v3出发按广度优先搜索的顺序遍历，得到的结点序列是v3→v2→v4→v1→v5
queue<int>q;
q.push(x);//从源点x出发，源点入队
f[x]=true;//标记源点
while(q.size()){ //若队列非空，则访问与队首元素相连的未访问点，并入队
		int tmp=q.front();//
		//cout<<tmp<<" ";
		q.pop();
		for(int i=1;i<=n;i++){
			if(!f[i] && a[tmp][i]){//找到与队首元素相连的点，并入队
				q.push(i);
				f[i]=true;
			}
		}	
	} 
图的最短路问题
求最短路的类型
单目标最短路径问题
单对顶点间的最短路径问题
每对顶点间的最短路径问题
floyd最短路
在无负权环的图中计算每对顶点间的最短路径问题，可以处理负权边。
//数据定义说明：
   map[][];    //存储图
   dist[][];   //dis[i,j]=k,i和j之间最短路径长度为K
//Floyed算法算法框架:
//① 从文件中读入图的邻接矩阵map；
   for(i=1;i<=n;i++) 
　　 for(j=1;j<=n;j++) 
　　　　cin>>map[i][j]);//读入数据
//② 数组初始化；
   for(i=1;i<=n;i++) 
　　 for(j=1;j<=n;j++)
             if(map[i][j]==0) map[i][j]=maxint;
   //把没有通路的点(map[I,j]=0)间的路径置为最大maxint
//③ Floyed算法框架；
void floyd()
{ int i,j,k;
  for(i=1;i<=n;i++)  //复抄数组
    for(j=1;j<=n;j++)
        dist[i][j]=map[i][j];
  
 for(k=1;k<=n;k++)     //枚举中间点
    for(i=1;i<=n;i++)      //枚举起点
       for(j=1;j<=n;j++)  //枚举终点
          if((  dist[i][k]!=maxint)  &&  (dist[k][j]!=maxint)   &&  (dist[i][k]+dist[k][j]<dist[i][j]))
                    dist[i][j]=dist[i][k]+dist[k][j];
}
Dijkstra算法
在边权非负的有向图中计算单源最短路径问题
主要思路：每次延长最短路时选择权最小的边，并调整最短路外每个结点至出发结点的路长
//① 将图中所有路径初始化为最大值，各点距离源点的路径长度为最大值
	memset(dis,Mx,sizeof dis);
	memset(g,Mx,sizeof g);

//②从文件中读入图的邻接矩阵g的m条边；
	for(int i=1;i<=m;i++){ 
		cin>>a>>b>>c;
		g[a][b]=g[b][a]=c;
	}

//③求出Dijkstra ；
void dij(int v){
		
	dis[v]=0;//处理源点
	vs[v]=true;//标记访问 
	for(int i=1;i<=n;i++)	dis[i]=g[v][i];//初始化,置初值
						//先更新与源点相连的点的路径长度 
	for(int i=1;i<=n-1;i++){//Dijkstra算法核心
		int m=Mx,k=0;
        
		for(int j=1;j<=n;j++){//找到最小点,注意判断条件
			if(!vs[j] && dis[j]<m){
				m=dis[j];//保存当前最短点
				k=j;
			}
		}
        
		vs[k]=true;//将最短点做标记 
		
		for(int j=1;j<=n;j++)//利用找到的点优化还没有访问的点 
			if(!vs[j] && g[k][j]!=Mx && dis[j]> dis[k] + g[k][j])
				dis[j]=dis[k]+g[k][j];//修正最短路径
	}
}
BF算法
在更一般的情况下解决单源点最短路径问题。所谓一般情况，指的是有向图的边权可以为负,但不允许存在负权回路。
BF算法具有分辨负权回路的能力。
主要思路：利用贪心的思想，
//① 存边
struct node{ //用结构体来存每一条边 
	int a,b,w;//a和b表示这条边的端点，w表示权值 
}edge[N];

	for(int i=1;i<=m;i++){
		cin>>d>>e>>f;
		edge[i]={d,e,f};
		//等同于 edge[i].a=d, edge[i].b=e, edge[i].w=f;
	}

//②初始化
	memset(dis,Mx,sizeof dis);//初始化所有点距离源点的距离为最大值 
	dis[1]=0;//初始化源点 

//③ BF 算法的核心
for(int i=1;i<n;i++) //迭代n-1次 
		for(int j=1;j<=m;j++) //每次迭代都枚举所有的边 
			if(dis[edge[j].a] + edge[j].w < dis[edge[j].b])//找到可以松弛的边 
				dis[edge[j].b] = dis[edge[j].a] + edge[j].w;//更新这条路径 
SPFA算法
是一种很高效的求图的最短路径的算法，正负权都可以，还能够判断负权回路问题。
用dijkstra的话，途中存在负权环的话就会失效。而bellman-ford的效率又相对较低。
Bellman_ford算法会遍历所有的边，但是有很多的边遍历了其实没有什么意义，我们只用遍历那些到源点距离变小的点所连接的边即可，只有当一个点的前驱结点更新了，该节点才会得到更新；因此考虑到这一点，我们将创建一个队列每一次加入距离被更新的结点。
核心思想：
维护一个队列，先将给出的源点放入队首，对其每条边连接的点进行松弛操作。如果改变后的点没在队列里，就将改变后的点加入队列。然后将上一个点取出队列，直到队列为空。
判断负权
判断负权环时，只要发现某一个点的拓展次数超过总结点数-1的话，就说明存在负权环，因为如果这个节点的最短距离不停地减小并且拓展次数超过总结点数时，该节点肯定被某个节点松弛两次或两次以上，说明存在一条到达他的权值为负的路径。
//邻接矩阵+spfa
//①数据使用
int g[N][N]; //邻接矩阵存储图，但SPFA更常用邻接表来存储图 
bool st[N];// 记录当前点是否在队列中 
int dis[N];//记录从源点到i的最短路径 
queue<int>q; //记录最短路径有更新的点 
//②初始化
memset(g,Mx,sizeof g);
memset(dis,Mx,sizeof dis);
for(int i=1;i<=m;i++){
    cin>>a>>b>>c;
    g[a][b]=g[b][a]=c;    
}
dis[1]=0;
q.push(1);
st[1]=true;
//SPFA是使用队列优化的bf算法，利用了每个点不会更新太多次的特点而发明，减少不必要的冗余计算 
//在形式上看和广搜非常类似，不同的是广搜中一个点出了队列后不可能再次进入队列
//SPFA中一个点可能会再次进入队列，因为一个点修改过其他的点后，过了一段时间可能会获得更短的路径
//于是要再次用来修改其他的点，这样反复进行下去。 
while(q.size()){
    int t=q.front();
    q.pop();
    st[t]=false; 
    for(int i=1;i<=n;i++){
        if(g[i][t]!=Mx && dis[t] + g[t][i] < dis[i]){ //枚举与t相连，且可更新最短路径的点 
            dis[i] = dis[t] + g[t][i]; //更新i点的最短路径 
            if(!st[i]) q.push(i), st[i] = true;//当前i点获得了更短路径，可以再次用来修改其他的点，因而入队 
        }
    }		
}
并查集
基本思想
判断元素间是否有联系，只要判断这两个元素是否属于同一个集合；
而给出元素间的联系，建立这种联系，则只需合并两个元素各自所属的集合
数据结构实现方法：一般采用数组来实现
基本操作
并查集的实现一般需要有如下操作：
Make(x) : 建立一个新的集合，其仅有的成员是x，且x没有在其他集合中出现过；
Union(x,y) : 将包含x和y 的动态集合合并为一个新的集合。
Find(x) : 返回一个指向包含x的集合的代表
int father[Mx];
int find(int x){// 寻找x所在集合的代表，非递归方法实现
    while ( father[x] != x) x = father[x];
    return x;
}
int find(int x){ //递归的方法来实现
    if(x != father[x]) return find(father[x]);
    return x;
}
void unnion(int r1, int r2){
    father[r1] = r2; //建立联系
    //或者 father[r2] = r1;
}
//缺点：当一条单链极长时，数据的这个“并” 和 “查” 相当费时
优化方法—路径压缩
让每一个元素直接指向根节点，那么查找的复杂度几乎为常数；
//① 初始化
for(int i=1; i<=n; i++) father[i] = i;
//每个元素属于一个单独的结合，所以每个元素以自己作为根节点
//② 寻找根节点，并压缩路径
int find(int x){
    if (father[x] != x) father[x] = find( father[x]);//路径压缩核心
    return father[x];
}
//③ 合并两个集合
void union(int x, int y){
    x = find(x);
    y = find(y);
    father[y] = x;
}
//④ 判断两个元素是否属于同一集合
bool judge(int x, int y){
    x = find(x);
    y = find(y);
    if(x == y) return true;
    else return false;
}
最小生成树问题
基本概念
在图的所有边中选出N-1条边，连接所有N个点，且这N-1条边的边权之和是所有方案中最小，这即为该图的最小生成树。用来解决用最小的代价用N-1条边连接N个点的问题。
prim算法
贪心的思想，每次循环都让一条新的最小的边加入生成树，n-1次循环结束后，得到一棵最小生成树。时间复杂度为O(n2)。
选取连接U(已选入)和V-U的所有边中的最短边。
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			cin>>g[i][j];
		}
	}
	memset(minn,0x7f,sizeof minn);
	minn[1]=0;
	for(int i=1;i<=n;i++){
		int k=0;
		for(int j=1;j<=n;j++){
			if(!u[j] && minn[j] < minn[k]) k=j;
		}
		u[k]=true;
		for(int j=1;j<=n;j++){
			if(!u[j] && g[k][j] < minn[j]) minn[j]=g[k][j];
		}
	}
kruscal算法
巧妙的利用并查集来求最小生成树的算法。
将一个连通块当成一个集合。
将所有的边按从小到大的顺序排序。并认为每一个点是独立的，分属于n个独立的集合。然后枚举每一条边，如果连着两个不同的集合，即将这条边加入最小生成树，这两个集合就合并成了一个新的集合。如果这条边属于同一集合，就跳过，直到选取了n-1条边为止。
仍然是贪心策略的运用。时间复杂度 O(E * logE),E为边数。
算法描述
初始化并查集，ans=0；
所有的边按权值从小到大排序；
计数器归零准备；
循环所有从小到大排序好的边：
if 这一条边的左右端点a,b不属于同一个集合
合并a，b所在集合，相当于把这条边加入最小生成树
ans += e[i].w;
k++;
if k==n-1,说明最小生成树已经生成，break
结束，ans为最小生成树的总权值之和。
for(int i=1;i<=m;i++){
    if(fd(e[i].a) != fd(e[i].b)){
        unionn(e[i].a,e[i].b);
        ans+=e[i].w;
        k++;
    }
    if(k==n-1) break;
}
